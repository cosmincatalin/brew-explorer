# Copilot Instructions for brew-explorer

## Project Overview
This is a Rust terminal user interface (TUI) application called "brew-explorer" that provides an interactive way to explore Homebrew packages on macOS.

## Tech Stack
- **Language**: Rust (2024 edition)
- **TUI Framework**: ratatui - Modern terminal UI library
- **Cross-platform Terminal**: crossterm - Terminal manipulation library
- **Homebrew Integration**: homebrew crate - Interface with Homebrew package manager

## Architecture Guidelines

### Code Organization
- Keep main.rs focused on application entry point and high-level coordination
- Keep UI logic separate from business logic

### TUI Best Practices
- Use ratatui's widget system for composable UI components
- Implement proper event handling with crossterm
- Follow the typical TUI application pattern:
  - Event loop with input handling
  - State management
  - Rendering cycle
- Ensure responsive UI that handles terminal resizing
- Implement keyboard shortcuts for common operations

### Error Handling
- Use `anyhow` for error handling
- Provide user-friendly error messages in the TUI
- Handle network errors gracefully when fetching package information
- Implement proper cleanup on application exit

### Performance Considerations
- Cache Homebrew package lists to avoid repeated expensive operations
- Implement lazy loading for large package lists
- Use async operations where appropriate for network calls
- Optimize rendering to avoid unnecessary redraws

## Feature Suggestions
When implementing features, consider:

### Core Features
- Browse installed Homebrew packages
- Search and filter packages
- View package details (description, dependencies, etc.)
- Install/uninstall packages directly from the TUI
- Update packages and Homebrew itself
- View package information and dependencies

## Other important rules
- Always use British English spelling, if something is written in American English, convert it to British English.
- Never use `timeout` in the CLI commands.
- Before you wrap things make absolutely sure the code compiles and runs without errors.
- Always use `cargo` for Rust commands, never `rustc`.
- Always use `cargo fmt` to format the code.
- Always use `cargo clippy` to check for common mistakes and improve the code.

### UI Components
- Package list with filtering capabilities
- Package detail view
- Search interface
- Status/notification area
- Help/keyboard shortcuts panel
- Progress indicators for long operations

### Navigation
- Vim-like keybindings (j/k for navigation, / for search, etc.)
- Tab navigation between different views
- Mouse support where appropriate

## Code Style
- Follow standard Rust conventions and clippy suggestions
- Use meaningful variable and function names
- Write comprehensive documentation for public interfaces
- Include unit tests for core functionality
- Use `cargo fmt` for consistent formatting

## Dependencies to Consider Adding
When extending functionality, consider these crates:
- `tokio` - For async operations
- `serde` + `serde_json` - For configuration and data serialization
- `clap` - For command-line argument parsing
- `dirs` - For cross-platform directory handling
- `log` + `env_logger` - For debugging and logging

## Testing Strategy
- Unit tests for business logic (brew operations, filtering, etc.)
- Integration tests for TUI components where possible
- Manual testing for user experience and terminal compatibility

## Platform Considerations
- Ensure compatibility with different terminal emulators
- Handle different screen sizes gracefully
- Consider color scheme compatibility (support for light/dark themes)
- Test on both macOS and Linux where Homebrew is available

## Common Patterns
When implementing features, use these patterns:
- State machines for complex UI flows
- Builder pattern for UI layout construction
- Event-driven architecture for user interactions
- Repository pattern for data access (Homebrew operations)

## Performance Notes
- Minimize system calls to `brew` command
- Cache results appropriately
- Use efficient data structures for large package lists
- Implement pagination for very large datasets
